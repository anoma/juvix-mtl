module Mtl.ExceptT;

import Mtl.MonadError open;
import Stdlib.Prelude open;

type ExceptT (Err : Type) (M : Type â†’ Type) (A : Type) :=
  mkExceptT@{
    runExceptT : M (Result Err A);
  };

instance
ExceptT-Functor
  {Err : Type} {M : Type -> Type} {{Functor M}} : Functor (ExceptT Err M) :=
  mkFunctor@{
    map {A B : Type} (f : A -> B) : ExceptT Err M A -> ExceptT Err M B
      | (mkExceptT x) := mkExceptT (Functor.map (Functor.map f) x);
  };

instance
ExceptT-Applicative
  {Err : Type} {M : Type -> Type} {{Monad M}} : Applicative (ExceptT Err M) :=
  mkApplicative@{
    ap {A B} : ExceptT Err M (A -> B) -> ExceptT Err M A -> ExceptT Err M B
      | (mkExceptT ef) (mkExceptT ev) :=
        mkExceptT
          do {
            mf <- ef;
            case mf of {
              | error e := Applicative.pure (error e)
              | ok f :=
                do {
                  mv <- ev;
                  Applicative.pure
                    case mv of {
                      | error e := error e
                      | ok v := ok (f v)
                    };
                }
            };
          };
    pure {A} (a : A) : ExceptT Err M A := mkExceptT (Applicative.pure (ok a));
  };

instance
ExceptT-Monad
  {Err : Type} {M : Type -> Type} {{Monad M}} : Monad (ExceptT Err M) :=
  mkMonad@{
    bind
      {A B}
      (x : ExceptT Err M A)
      (f : A -> ExceptT Err M B)
      : ExceptT Err M B :=
      mkExceptT
        do {
          a <- ExceptT.runExceptT x;
          case a of {
            | error e := pure (error e)
            | ok r := ExceptT.runExceptT (f r)
          };
        };
  };

instance
ExceptT-MonadError
  {Err} {M : Type -> Type} {{mon : Monad M}} : MonadError Err (ExceptT Err M) :=
  mkMonadError@{
    monad := ExceptT-Monad;
    throw {A} (err : Err) : ExceptT Err M A := mkExceptT (pure (error err));
  };

runExcept {Err A} {M : Type -> Type} : ExceptT Err M A -> M (Result Err A)
  | (mkExceptT x) := x;
