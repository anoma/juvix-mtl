module Mtl.Data.StateT;

import Stdlib.Prelude open;
import Mtl.Trait.State open;
import Mtl.Trait.MonadTransformer open;
-- TODO MonadTransformer instance
type StateT (S : Type) (M : Type → Type) (A : Type) :=
  mkStateT@{
    runStateT : S → M (Pair A S);
  };

runState
  {S A : Type} {M : Type → Type} (s : S) (m : StateT S M A) : M (Pair A S) :=
  StateT.runStateT m s;

evalState
  {S A : Type}
  {M : Type → Type}
  {{Functor M}}
  (s : S)
  (m : StateT S M A)
  : M A := Functor.map fst (runState s m);

state
  {A S}
  {M : Type -> Type}
  {{Applicative M}}
  (f : S -> Pair A S)
  : StateT S M A := mkStateT \{s := Applicative.pure (f s)};

instance
StateT-Functor
  {S : Type} {M : Type → Type} {{func : Functor M}} : Functor (StateT S M) :=
  mkFunctor@{
    map {A B : Type} (f : A → B) : StateT S M A → StateT S M B
      | (mkStateT S→M⟨A×S⟩) :=
        mkStateT λ{s := Functor.map λ{(a, s') := f a, s'} (S→M⟨A×S⟩ s)};
  };

instance
StateT-Applicative
  {S : Type} {M : Type -> Type} {{Monad M}} : Applicative (StateT S M) :=
  mkApplicative@{
    ap {A B} : StateT S M (A -> B) -> StateT S M A -> StateT S M B
      | (mkStateT mf) (mkStateT mx) :=
        mkStateT
          \{s :=
            do {
              f, s' <- mf s;
              x, s'' <- mx s';
              Applicative.pure (f x, s'');
            }};
    pure {A : Type} (a : A) : StateT S M A :=
      mkStateT λ{s := Applicative.pure (a, s)};
  };

instance
StateT-Monad
  {S : Type} {M : Type → Type} {{mon : Monad M}} : Monad (StateT S M) :=
  mkMonad@{
    applicative := StateT-Applicative;
    bind
      {A B : Type} (x : StateT S M A) (f : A → StateT S M B) : StateT S M B :=
      mkStateT
        λ{s :=
          StateT.runStateT x s >>= λ{(a, s') := StateT.runStateT (f a) s'}};
  };


instance
StateT-State
  {S : Type} {M : Type → Type} {{Monad M}} : State S (StateT S M) :=
  mkState@{
    monad := StateT-Monad;
    get : StateT S M S := mkStateT λ{s := Applicative.pure (s, s)};
    put (s : S) : StateT S M Unit :=
      mkStateT λ{_ := Applicative.pure (unit, s)};
  };
